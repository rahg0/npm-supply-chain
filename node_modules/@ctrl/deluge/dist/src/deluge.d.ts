import { ofetch } from 'ofetch';
import { Cookie } from 'tough-cookie';
import type { Jsonify } from 'type-fest';
import type { AddTorrentOptions as NormalizedAddTorrentOptions, AllClientData, NormalizedTorrent, TorrentClient, TorrentClientConfig, TorrentClientState } from '@ctrl/shared-torrent';
import type { AddTorrentOptions, AddTorrentResponse, BooleanStatus, ConfigResponse, DefaultResponse, DelugeSettings, GetHostsResponse, GetHostStatusResponse, ListMethods, PluginInfo, PluginsListResponse, StringStatus, TorrentFiles, TorrentInfo, TorrentListResponse, TorrentOptions, TorrentStatus, Tracker, UploadResponse } from './types.js';
interface DelugeState extends TorrentClientState {
    auth: {
        cookie?: Cookie;
        msgId: number;
    };
}
export declare class Deluge implements TorrentClient {
    static createFromState(config: Readonly<TorrentClientConfig>, state: Readonly<Jsonify<DelugeState>>): Deluge;
    config: TorrentClientConfig;
    state: DelugeState;
    constructor(options?: Partial<TorrentClientConfig>);
    exportState(): Jsonify<DelugeState>;
    resetSession(): void;
    getHosts(): Promise<GetHostsResponse>;
    /**
     * Gets host status
     * @param host pass host id from `this.getHosts()`
     */
    getHostStatus(host: string): Promise<GetHostStatusResponse>;
    /**
     * Connects deluge and returns a list of available methods
     * @param host index of host to use in result of get hosts
     * @param hostIdx index of host to use in result of get hosts
     */
    connect(selectedHost?: string, hostIdx?: number): Promise<ListMethods>;
    connected(): Promise<boolean>;
    /**
     * Disconnects deluge - warning all instances connected to this client will also be disconnected.
     * Other instances may also reconnect. Not really sure why you would want to disconnect
     */
    disconnect(): Promise<boolean>;
    /**
     * Checks current session is valid
     * @returns true if valid
     */
    checkSession(): Promise<boolean>;
    /**
     * Login deluge
     * @returns true if success
     */
    login(): Promise<boolean>;
    /**
     * Logout deluge
     * @returns true if success
     */
    logout(): Promise<boolean>;
    /**
     * returns the version ex - `2.0.3-2-201906121747-ubuntu18.04.1`
     */
    getVersion(): Promise<StringStatus>;
    /**
     * used to get torrent info before adding
     * @param tmpPath use path returned from upload torrent looks like `'/tmp/delugeweb-DfEsgR/tmpD3rujY.torrent'`
     */
    getTorrentInfo(tmpPath: string): Promise<TorrentInfo>;
    /**
     * Lists methods
     * @param auth disable or enable auth connection
     * @returns a list of method names
     */
    listMethods(auth?: boolean): Promise<ListMethods>;
    upload(torrent: string | Uint8Array<ArrayBuffer>): Promise<UploadResponse>;
    /**
     * Download a torrent from url, pass the result to {@link Deluge.addTorrent}
     * @param url
     * @param cookies
     * @returns file path
     */
    downloadFromUrl(url: string, cookies?: string): Promise<string>;
    addTorrent(torrent: string | Uint8Array<ArrayBuffer>, config?: Partial<AddTorrentOptions>): Promise<AddTorrentResponse>;
    normalizedAddTorrent(torrent: string | Uint8Array<ArrayBuffer>, options?: Partial<NormalizedAddTorrentOptions>): Promise<NormalizedTorrent>;
    addTorrentMagnet(magnet: string, config?: Partial<AddTorrentOptions>): Promise<BooleanStatus>;
    /**
     *
     * @param torrentId torrent id from list torrents
     * @param removeData (default: false) If true, remove the data from disk
     */
    removeTorrent(torrentId: string, removeData?: boolean): Promise<BooleanStatus>;
    changePassword(password: string): Promise<BooleanStatus>;
    getAllData(): Promise<AllClientData>;
    listTorrents(additionalFields?: string[], filter?: Record<string, string>): Promise<TorrentListResponse>;
    getTorrent(id: string): Promise<NormalizedTorrent>;
    /**
     * get torrent state/status
     * @param additionalFields fields ex - `['label']`
     */
    getTorrentStatus(torrentId: string, additionalFields?: string[]): Promise<TorrentStatus>;
    /**
     * Get list of files for a torrent
     */
    getTorrentFiles(torrentId: string): Promise<TorrentFiles>;
    pauseTorrent(torrentId: string): Promise<DefaultResponse>;
    resumeTorrent(torrentId: string): Promise<DefaultResponse>;
    setTorrentOptions(torrentId: string, options?: Partial<TorrentOptions>): Promise<DefaultResponse>;
    setTorrentTrackers(torrentId: string, trackers?: Tracker[]): Promise<DefaultResponse>;
    updateTorrentTrackers(torrentId: string): Promise<DefaultResponse>;
    verifyTorrent(torrentId: string): Promise<DefaultResponse>;
    setTorrentLabel(torrentId: string, label: string): Promise<DefaultResponse>;
    addLabel(label: string): Promise<DefaultResponse>;
    removeLabel(label: string): Promise<DefaultResponse>;
    getLabels(): Promise<ListMethods>;
    queueTop(torrentId: string): Promise<DefaultResponse>;
    queueBottom(torrentId: string): Promise<DefaultResponse>;
    queueUp(torrentId: string): Promise<DefaultResponse>;
    queueDown(torrentId: string): Promise<DefaultResponse>;
    getConfig(): Promise<ConfigResponse>;
    setConfig(config: Partial<DelugeSettings>): Promise<DefaultResponse>;
    getPlugins(): Promise<PluginsListResponse>;
    getPluginInfo(plugins: string[]): Promise<PluginInfo>;
    enablePlugin(plugins: string[]): Promise<DefaultResponse>;
    disablePlugin(plugins: string[]): Promise<DefaultResponse>;
    request<T extends object>(method: string, params?: any[], needsAuth?: boolean, autoConnect?: boolean): Promise<ReturnType<typeof ofetch.raw<T>>>;
    private _validateAuth;
}
export {};
